pragma solidity >=0.4.22 <0.6.0;

contract NewContract {
    
    struct gamer {
        uint256 numberPick;
        uint256 deposit;
    }
    
    mapping (address=>gamer) gamers;
    address[2] person;
    bool public gameStarted = false;
    bool public tableIsFull = false;

    function startGame (uint numberPicked) payable external{
        //cannot start a new game before the old game finished
        require(gameStarted==false);
        // pick a number between 1 and 5
        require((numberPicked>=1)&&(numberPicked<=5));  
        // guess a number between 1 and 5
        require((msg.value>=1 ether)&&(msg.value<=5 ether));
        
        // put the number in arguement   
        gamers[msg.sender].numberPick = numberPicked*1e18;
        // deposit = the guess value = msg.value
        gamers[msg.sender].deposit = msg.value;
        person[0] = msg.sender;
        gameStarted = !gameStarted;
    }   
    function joinGame (uint numberPicked) payable external{
        //can only join when there is a new game
        require(gameStarted==true);
        //can not join when place is occupied
        require(tableIsFull==false);
        // pick a number between 1 and 5
        require((numberPicked>=1)&&(numberPicked<=5));  
        // guess a number between 1 and 5
        require((msg.value>=1 ether)&&(msg.value<=5 ether));
        
        gamers[msg.sender].numberPick = numberPicked*1e18;
        gamers[msg.sender].deposit = msg.value;
        person[1] = msg.sender;
        tableIsFull = !tableIsFull;
        getResult();
      
    } 
    
    function getResult () internal{
        //  if gamer0 win, transfer the gamer1's deposit to gamer0
        if((gamers[person[0]].deposit==gamers[person[1]].numberPick)&&(gamers[person[1]].deposit!=gamers[person[0]].numberPick)){
            gamers[person[0]].deposit = gamers[person[0]].deposit + gamers[person[1]].deposit;
            gamers[person[1]].deposit = 0;
        }
        //  if gamer 1 win, transfer the gamer0's deposit to gamer1
        else if ((gamers[person[0]].deposit!=gamers[person[1]].numberPick)&&(gamers[person[1]].deposit==gamers[person[0]].numberPick)){
            gamers[person[1]].deposit = gamers[person[0]].deposit + gamers[person[1]].deposit;
            gamers[person[0]].deposit = 0;
        }
        // if tie nothing changed
        else {
            
        }
    }

     function withdraw() public {
        // only call this after the game finished
        require(gameStarted ==true);
        require(tableIsFull ==true);
        // has money to withdraw
        require(gamers[msg.sender].deposit>0);
        uint256 amount = gamers[msg.sender].deposit;
        gamers[msg.sender].deposit = 0;
        msg.sender.transfer(amount);
        
        if(gamers[person[0]].deposit==0 && gamers[person[1]].deposit==0){
        gameStarted = !gameStarted;
        tableIsFull = !tableIsFull;
       }
    }
}
