pragma solidity >=0.4.22 <0.6.0;

contract MorraContract {
    
    struct gamer {
        address payable gamerAddress;
        uint256 numberPick;
        uint256 numbeGuess;
    }
    bool public gameStarted = false;
    gamer[2] gamers;  
    uint public temp;
    address owner;
    string ownerName;
    
    constructor(string memory name) public {
        owner = msg.sender;
        ownerName = name;
    }
    
    function bet (uint numberPicked) payable external{
        // input validation check
        require((numberPicked>=1)&&(numberPicked<=5));  
        require((msg.value>=1 ether)&&(msg.value<=5 ether));
        
        // if game haven't started, assign the gambler a seat and wait for another gambler
        if(gameStarted==false){
            assignSeat(0,numberPicked);
        }else if(gameStarted==true){
            assignSeat(1,numberPicked);
            getResult ();
        }
        gameStarted = !gameStarted;
    }
    
    function assignSeat(uint number,uint numberPicked) internal{
        gamers[number].gamerAddress = msg.sender;
        gamers[number].numberPick = msg.value;
        gamers[number].numbeGuess = numberPicked*1e18; //convert interger to Wei
    }
    
    function getResult () internal{
        temp = gamers[0].numberPick + gamers[1].numberPick;
        //  if gamer 1 win
        if( (gamers[0].numberPick == gamers[1].numbeGuess)&&(gamers[1].numberPick != gamers[0].numbeGuess)){
            sendEther(gamers[1].gamerAddress,temp);
        }
        //  if gamer 0 win
        else if( (gamers[1].numberPick == gamers[0].numbeGuess) &&(gamers[0].numberPick != gamers[1].numbeGuess)){
            sendEther(gamers[0].gamerAddress,temp);
        } 
        // if it is a tie
        else{
            sendEther(gamers[0].gamerAddress,gamers[0].numberPick);
            sendEther(gamers[1].gamerAddress,gamers[1].numberPick);
        }
    }
    
    function sendEther (address payable target, uint number) internal{
        target.transfer(number);
    }
    
}
